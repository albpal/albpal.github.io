# P2PK, P2PKH, P2SH, P2SH-P2WPK, P2WPK, P2SH-P2WSH, P2WSH... what the f**

Bitcoin, as a public ledger, maintains a set of Unspent Transaction Outputs (UTXOs). Each UTXO has a certain amount of bitcoins locked in. The sum of all bitcoins in UTXOs you can unlock is your balance.

## Main concepts: ScriptPubKey and ScriptSig

When someone wants to send bitcoins (from UTXOs) has to fill a field inside the transaction. This field is a *lock* and will be only opened if its conditions are satisfied by the redeemer (who wants to spend bitcoins). This field is named **Pubkey Script or ScriptPubKey**.

By the other hand, the redeemer has to provide the necessary input data to Pubkey script to evaluate correctly. Otherwise, he won't be able to spend bitcoin. This input data is named **Signature script or ScriptSig**.

That's it, only 2 terms are used to lock/unlock bitcoins:

1. Pubkey or ScriptPubKey
2. Signature script or ScriptSig

A tip to remember these concepts:

1. Pubkey or ScriptPubKey: 
    * PubKey (Public Key) --> Lock bitcoins
2. Signature script or ScriptSig: 
    * Sig (Signature) --> Unlock bitcoins

These two variables are scripts, ie are programs, written in a language similar to Forth:

```Bitcoin uses a scripting system for transactions. Forth-like, Script is simple, stack-based, and processed from left to right. It is intentionally not Turing-complete, with no loops.```https://en.bitcoin.it/wiki/Script

For a detailed overview about how this language is executed, see the below video by Andreas Antonopoulos:


[![Advanced Bitcoin Scripting -- Part 1: Transactions & Multisig](http://img.youtube.com/vi/8FeAXjkmDcQ/0.jpg)](http://www.youtube.com/watch?v=8FeAXjkmDcQ)

## Available script templates for ScriptPubKey and ScriptSig

However, not all arbitrary scripts can be placed on these variables. Due to security reasons, a standard transaction only can have one of the following script templates, ie series of commands, in both ScriptPubKey and ScriptSig[[1]]:

> Next to the name template, I've placed the BIP defining the new standard if it exists

* Pubkey (P2PK) (first bitcoin 0.1 release)
  * Script PubKey: ``<pubkey> OP_CHECKSIG``
  * ScriptSig: ``<sig>``
* Pay To Public Key Hash (first bitcoin 0.1 release)
  * ScriptPubKey: ``OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG``
  * ScriptSig: ``<Sig> <PubKey>``
* Pay To Script Hash (P2SH) [BIP-16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki)
  * ScriptPubKey: ``OP_HASH160 <Hash160(redeemScript)> OP_EQUAL``
  * ScriptSig: ``<sig> [sig] [sig...] <redeemScript>``
* Multisig [BIP-11](https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki)
  * ScriptPubKey: ``<m> <A pubkey> [B pubkey] [C pubkey...] <n> OP_CHECKMULTISIG``
  * ScriptSig: ``OP_0 <A sig> [B sig] [C sig...]``
* Null Data (it creates an UTXO that cannot be spent, we'll ignore this case)
  * ScriptPubKey: ``OP_RETURN <0 to 40 bytes of data>``
  * ScriptSig: ``(Null data scripts cannot be spent, so there's no signature script.)``

All OP_XX are script operators. Signatures (sig) are digital signatures of the transaction data, nothing new here. But what about:

* pubkey
* PubkeyHash
* redeemScript

All three of them represent the *receiver address*. Let's see how to generate them.

## Generating addresses

### pubkey

This type of addresses generally arenâ€™t used in new transactions anymore. It's the public key generated by the Elliptic Curve Digital Signature Algorithm (ECDSA):

```python

import ecdsa
privKey = # number > 0 and number <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140
vk = ecdsa.SigningKey.from_string(privKey, curve=ecdsa.SECP256k1).get_verifying_key()

```

### PubkeyHash

If ECDSA gets compromised, the bitcoins stored using the previous *lock*, ie a public key, could be stolen. Thus, this method hash the public key to add extra security. Hashing the public key, and if ECDSA gets compromised, would add an extra security layer and the *hacker* wont be able to spend the funds (SHA256+RIPEMD160+ECDSA have to be broken at the same time). There are other security concerns which makes this option more secure than raw public key (checksum, for example).

```python

import binascii
pubkey = # Previous public key
decoded_address = binascii.unhexlify("00") + hash160(pubkey).digest()
btc_addr = base58.b58encode_check(decoded_address)

```
The prefix `0x00` is the version byte for this address type.

This type of addresses start with "1" in main net. For example: `19LH6eahzaBVU9rz6TK81rUJ8ZfdyAsM3S`

### redeemScript

> This new address format was introduced at [BIP13](https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki).

Okay... Now things will become interesting (and a bit more complicated). In the previous addresses, the address is tied one to one to a public key (identity). No other option is given to the redeemer to spend his bitcoins. With this type of addresses, the logic to spend the bitcoins is delegated to the redeemer (among other security concerns).

Only the redeemScript will be able to spend the bitcoins (not a public key). Furthermore, the script itself has to evaluate to true. Thus, two more conditions have to be fulfilled to spend bitcoins sent to this type of addresses:

* Give a script whom hash matches the address
* The evaluation of the script itself is successful

As in the case of ScriptPubkey and ScriptSig, redeemScript only can be the same previous list of templates we have seen so far (except P2SH itself), ie:

* `<pubkey> OP_CHECKSIG`
* `OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG`
* `<m> <A pubkey> [B pubkey] [C pubkey...] <n> OP_CHECKMULTISIG`

Then, we can choose a P2SH payment method to an address whom redeem script is like P2PK ScriptPubKey (the first one). Or maybe you want to use a multisig redeem script... that's because we said the redeemer decide how the bitcoins can be spent without nobody knowing it! If you know the redeem script, you can say `P2SH-<redeem script type>`, for example, `P2SH-P2PK` or `P2SH-P2PKH`, etc.

The redeem script will be provided by the redeemer inside the ScriptSig: `<sig1> [<sig2>, <sig3>, ...] {serialized redeem script}`

## Summarizing

|Receiver wants to be paid using|Receiver address derived from...  |To unlock funds    |
|:-----------------------------:|:--------------------------------:|:-----------------:|
|P2PK                           |PublicKey                         |signature          |
|P2PKH                          |BASE58_ENCODE(HASH160(PublicKey)) |sig + pubkey       |
|P2SH                           |Redeem Script                     | data+redeem script|

Reedem scripts:

| Payment method|Reedem script template                                             |Alias|
|:-------------:|:-----------------------------------------------------------------:|:-----:|
|P2SH           |P2PK:`<pubkey> OP_CHECKSIG`                                      |P2SH-P2PK|
|P2SH           |P2PKH:`OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG`|P2SH-P2PKH|
|P2SH           |P2 Multisig:`<m> <A pubkey> [B pubkey] [C pubkey...] <n> OP_CHECKMULTISIG`|P2SH Multisig

## References

[1]: https://bitcoin.org/en/developer-guide#standard-transactions[https://bitcoin.org/en/developer-guide#standard-transactions]

1. https://bitcoin.org/en/developer-guide#standard-transactions
